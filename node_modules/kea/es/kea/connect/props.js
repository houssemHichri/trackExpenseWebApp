import { deconstructMapping } from './mapping';

export function selectPropsFromLogic() {
  var propsMapping = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var _deconstructMapping = deconstructMapping(propsMapping),
      propsArray = _deconstructMapping.response,
      logics = _deconstructMapping.logics;

  if (!propsArray) {
    return;
  }

  var hash = {};
  var meta = {};

  propsArray.forEach(function (_ref) {
    var logic = _ref[0],
        from = _ref[1],
        to = _ref[2];

    // we were given a function (state) => state.something as logic input
    var isFunction = typeof logic === 'function' && !logic._isKeaFunction;
    var selectors = isFunction ? null : logic.selectors ? logic.selectors : logic;

    if (from === '*') {
      hash[to] = isFunction ? logic : logic.selector ? logic.selector : selectors;
    } else if (isFunction) {
      hash[to] = function (state, props) {
        return (logic(state, props) || {})[from];
      };
    } else if (typeof selectors[from] !== 'undefined') {
      hash[to] = selectors[from];
    } else if (logic && logic._isKeaSingleton === false) {
      console.error('[KEA-LOGIC] it\'s not possible to connect to dynamic logic stores directly. Use "logic.withKey(props => props.id)" instead');
      console.trace();
    } else {
      console.error('[KEA-LOGIC] selector "' + from + '" missing for logic:', logic);
      console.trace();
    }
  });

  // add some metadata, especially if we're connecting a to dynamic logic store
  meta.withKeyCreator = false;
  meta.keyCreators = [];
  logics.forEach(function (logic) {
    var keyCreator = logic && logic._keaKeyCreator && typeof logic._keaKeyCreator === 'function' ? logic._keaKeyCreator : null;

    if (keyCreator) {
      meta.withKeyCreator = true;
      meta.keyCreators.push(keyCreator);
    }
  });

  return { props: hash, meta: meta };
}