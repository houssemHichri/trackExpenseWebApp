var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

import { selectPropsFromLogic } from './connect/props';
import { propTypesFromConnect } from './connect/prop-types';
import { combineReducerObjects, convertReducerArrays } from './logic/reducer';
import { pathSelector, safePathSelector, createSelectors } from './logic/selectors';
import { createActions } from './actions/create';
import { selectActionsFromLogic } from './connect/actions';

import convertConstants from '../utils/convert-constants';
import shallowEqual from '../utils/shallow-equal';

import { createSelector } from 'reselect';
import { connectAdvanced } from 'react-redux';

import { setCache, getCache } from './cache';

import { firstReducerRoot, isSyncedWithStore, addReducer } from './reducer';

import { globalPlugins, activatePlugin } from './plugins';

function isStateless(Component) {
  return !Component.prototype.render;
}

var nonamePathCounter = 0;

function createUniquePathFunction() {
  var keyCreator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var reducerRoot = firstReducerRoot();
  if (!reducerRoot) {
    console.error('[KEA] Could not find the root of the keaReducer! Make sure you call keaReducer() before any call to kea() is made. See: https://kea.js.org/api/reducer');
  }

  var inlinePath = [reducerRoot, '_kea', 'inline-' + nonamePathCounter++];

  if (keyCreator) {
    return function (key) {
      return inlinePath.concat([key]);
    };
  } else {
    return function () {
      return inlinePath;
    };
  }
}

var hydrationAction = '@@kea/hydrate store';

export function kea(_input) {
  // a few helpers for later
  var hasManualPath = !!_input.path;
  var hasConnect = !!_input.connect;
  var hasLogic = !!(_input.actions || _input.reducers || _input.selectors);
  var shouldMountReducer = hasManualPath || !!_input.reducers;

  // clone the input and add a path if needed
  var input = Object.assign({}, _input, hasManualPath ? {} : { path: createUniquePathFunction() });

  // this will be filled in and passed to plugins as needed
  var output = {
    activePlugins: {},
    isSingleton: !input.key,

    path: null,
    constants: {},

    connected: { actions: {}, selectors: {}, propTypes: {} },
    created: { actions: {}, reducerObjects: {}, selectors: {}, propTypes: {}, defaults: {} },

    actions: {},
    reducers: {},
    selector: null,
    selectors: {},
    propTypes: {},
    defaults: {}
  };

  var plugins = globalPlugins;

  if (input.plugins) {
    plugins = Object.assign({}, globalPlugins);
    input.plugins.forEach(function (plugin) {
      activatePlugin(plugin, plugins);
    });
  }

  // check which plugins are active based on the input
  plugins.isActive.forEach(function (isActive) {
    output.activePlugins[isActive._name] = isActive(input, output);
  });

  // set the constants
  output.constants = input.constants ? convertConstants(input.constants(output)) : {};

  // anything to connect to?
  if (hasConnect) {
    // the { connect: { props, actions } } part
    var connect = input.connect || {};

    var _selectActionsFromLog = selectActionsFromLogic(connect.actions),
        connectedActions = _selectActionsFromLog.actions,
        actionsMeta = _selectActionsFromLog.meta;

    var _selectPropsFromLogic = selectPropsFromLogic(connect.props),
        connectedProps = _selectPropsFromLogic.props,
        propsMeta = _selectPropsFromLogic.meta;

    // store connected actions, selectors and propTypes separately


    output.connected = {
      actions: connectedActions,
      selectors: connectedProps,
      propTypes: propTypesFromConnect(connect)

      // if we're connecting to dynamic components with key creators (props => props.id)
      // we need to make sure we are dynamic as well
    };if (actionsMeta.withKeyCreator || propsMeta.withKeyCreator) {
      // set as dynamic logic store
      output.isSingleton = false;

      // create a key function if needed
      if (!input.key) {
        if (hasManualPath) {
          console.error('[KEA] You must provide a key to components which connect to dynamic logic stores! Overwriting path!', input);
        }

        var keyCreators = actionsMeta.keyCreators.concat(propsMeta.keyCreators);

        // the created key is the combination of all input keys used to connect to logic stores
        input.key = function (props) {
          return keyCreators.map(function (c) {
            return c(props).toString();
          }).join(',');
        };
        input.path = createUniquePathFunction(input.key);
      }
    }

    // set actions, selectors and propTypes to the connected ones
    Object.assign(output, output.connected);

    // run the afterConnect plugin hook
    plugins.afterConnect.forEach(function (f) {
      return f(input, output);
    });
  }

  // we don't know yet if it's going to be a singleton (no key) or inline (key)
  // however the actions and constants are common for all, so get a path without the dynamic
  // component and initialize them
  output.path = input.path('').filter(function (p) {
    return p;
  });

  if (input.actions) {
    // create new actions
    output.created.actions = createActions(input.actions(output), output.path);

    // add them to the actions hash
    output.actions = Object.assign(output.actions, output.created.actions);
  }

  // if we are passing along any propTypes, add them
  if (input.propTypes) {
    output.propTypes = Object.assign(output.propTypes, input.propTypes);
  }

  // if it's a singleton, create all the reducers and selectors and add them to redux
  if (output.isSingleton) {
    // we have reducer or selector inputs, create all output reducers and selectors
    // ... or the "path" is manually defined, so we must put something in redux
    if (hasManualPath || input.reducers || input.selectors) {
      // create the reducers from the input
      output.created.reducerObjects = input.reducers ? convertReducerArrays(input.reducers(output)) : {};

      // run plugins on the created reducer objects
      plugins.mutateReducerObjects.forEach(function (f) {
        return f(input, output, output.created.reducerObjects);
      });

      // add propTypes
      Object.keys(output.created.reducerObjects).forEach(function (reducerKey) {
        var reducerObject = output.created.reducerObjects[reducerKey];
        if (reducerObject.type) {
          output.created.propTypes[reducerKey] = reducerObject.type;
        }

        output.created.defaults[reducerKey] = reducerObject.value;
        output.reducers[reducerKey] = reducerObject.reducer;
      });

      // combine the created reducers into one
      output.reducer = combineReducerObjects(output.path, output.created.reducerObjects);

      // run plugins on the created reducer
      plugins.mutateReducer.forEach(function (f) {
        return f(input, output, output.reducer);
      });

      // add a global selector for the path
      output.selector = function (state) {
        return pathSelector(output.path, state);
      };

      // create selectors from the reducers
      output.created.selectors = createSelectors(output.path, Object.keys(output.created.reducerObjects));

      // add the created selectors and propTypes to the output
      output.selectors = Object.assign(output.selectors, output.created.selectors);
      output.propTypes = Object.assign(output.propTypes, output.created.propTypes);
      output.defaults = Object.assign(output.defaults, output.created.defaults);

      // any additional selectors to create?
      if (input.selectors) {
        var selectorResponse = input.selectors(output);

        Object.keys(selectorResponse).forEach(function (selectorKey) {
          // s == [() => args, selectorFunction, propType]
          var s = selectorResponse[selectorKey];
          var args = s[0]();

          if (s[2]) {
            output.created.propTypes[selectorKey] = s[2];
            output.propTypes[selectorKey] = output.created.propTypes[selectorKey];
          }

          output.created.selectors[selectorKey] = createSelector.apply(undefined, args.concat([s[1]]));
          output.selectors[selectorKey] = output.created.selectors[selectorKey];
        });
      }

      // hook up the reducer to the global kea reducers object
      if (shouldMountReducer) {
        addReducer(output.path, output.reducer);
      }
    }

    plugins.afterCreateSingleton.forEach(function (f) {
      return f(input, output);
    });
  }

  // we will return this function which can wrap the logic store around a component
  var response = function response(Klass) {
    if (!Klass) {
      console.error('[KEA] Logic stores must be wrapped around React Components or stateless functions!', input, output);
      return;
    }

    // inject the propTypes to the class
    Klass.propTypes = Object.assign({}, output.propTypes, Klass.propTypes || {});

    // dealing with a Component
    if (!isStateless(Klass)) {
      // inject to the component something that
      // converts this.props.actions to this.actions
      if (!Object.getOwnPropertyDescriptor(Klass.prototype, 'actions')) {
        Object.defineProperty(Klass.prototype, 'actions', {
          get: function actions() {
            return this.props.actions;
          }
        });
      }

      // Since Klass == Component, tell the plugins to add themselves to it.
      // if it's a stateless functional component, we'll do it in the end with Redux's Connect class
      plugins.injectToClass.forEach(function (f) {
        return f(input, output, Klass);
      });
    }

    var selectorFactory = function selectorFactory(dispatch, factoryOptions) {
      var lastProps = {};
      var result = null;

      if (!isSyncedWithStore()) {
        dispatch({ type: hydrationAction });
      }

      return function (nextState, nextOwnProps) {
        // get the key if it's defined
        var key = input.key ? input.key(nextOwnProps) : null;

        // if the key function was defined and returns undefined, something is up. give an error
        if (typeof key === 'undefined') {
          console.error('"key" can\'t be undefined in path: ' + input.path('undefined').join('.'));
        }

        // get the path of this logic store
        var path = input.path(key);
        var joinedPath = path.join('.');

        // get a selector to the root of the path in redux. cache it so it's only created once
        var selector = getCache(joinedPath, 'selector');
        if (!selector) {
          selector = function selector(state) {
            return pathSelector(path, state);
          };
          setCache(joinedPath, { selector: selector });
        }

        var selectors = getCache(joinedPath, 'selectors');

        // add data from the connected selectors into nextProps
        // only do this if we have no own reducers/selectors, otherwise it gets done later
        if (hasConnect && !hasLogic && !selectors) {
          selectors = output.connected.selectors;

          // store in the cache. kea-saga wants to access this. TODO: find a better way?
          setCache(joinedPath, { selectors: output.connected.selectors });
        }

        // did we create any reducers/selectors inside the logic store?
        if (hasLogic) {
          // now we must check if the reducer is already in redux, or we need to add it
          // if we need to add it, create "dummy" selectors for the default values until then

          // is the reducer created? if we have "true" in the cache, it's definitely created
          var reduxMounted = shouldMountReducer && !!getCache(joinedPath, 'reduxMounted');

          // if it's not and should eventually be, let's double check. maybe it is now?
          if (shouldMountReducer && !reduxMounted) {
            try {
              reduxMounted = typeof selector(nextState) !== 'undefined';
            } catch (e) {
              reduxMounted = false;
            }
          }

          // we don't have the selectors cached with the current reduxMounted state!
          if (getCache(joinedPath, 'reduxMounted') !== reduxMounted) {
            // create a new "output" that also contains { path, key, props }
            // this will be used as /input/ to create the reducers and selectors
            var wrappedOutput = Object.assign({}, output, { path: path, key: key, props: nextOwnProps });

            // we can't just recycle this from the singleton, as the reducers can have defaults that depend on props
            var reducerObjects = input.reducers ? convertReducerArrays(input.reducers(wrappedOutput)) : {};

            // run plugins on the created reducer objects
            plugins.mutateReducerObjects.forEach(function (f) {
              return f(input, output, reducerObjects);
            });

            // not in redux, so add the reducer!
            if (shouldMountReducer && !reduxMounted) {
              var reducer = combineReducerObjects(path, reducerObjects);

              // run plugins on the created reducer
              plugins.mutateReducer.forEach(function (f) {
                return f(input, output, reducer);
              });

              addReducer(path, reducer);
            }

            // send a hydration action to redux, to make sure that the store is up to date on the next render
            if (!isSyncedWithStore()) {
              dispatch({ type: hydrationAction });
            }

            // get connected selectors and selectors created from the reducer
            var connectedSelectors = output.connected ? output.connected.selectors : {};
            var createdSelectors = createSelectors(path, Object.keys(reducerObjects));

            // if the reducer is in redux, get real reducer selectors. otherwise add dummies that return defaults
            if (reduxMounted) {
              selectors = Object.assign({}, connectedSelectors, createdSelectors);
            } else {
              // if we don't know for sure that the reducer is in the current store output,
              // then fallback to giving the default value
              selectors = Object.assign({}, connectedSelectors || {});
              Object.keys(reducerObjects).forEach(function (key) {
                selectors[key] = function (state) {
                  try {
                    return createdSelectors[key](state, nextOwnProps);
                  } catch (error) {
                    return reducerObjects[key].value;
                  }
                };
              });
            }

            // create the additional selectors
            var _selectorResponse = input.selectors ? input.selectors(Object.assign({}, wrappedOutput, { selectors: selectors })) : {};

            Object.keys(_selectorResponse).forEach(function (selectorKey) {
              // s == [() => args, selectorFunction, propType]
              var s = _selectorResponse[selectorKey];
              var args = s[0]();
              selectors[selectorKey] = createSelector.apply(undefined, args.concat([s[1]]));
            });

            // store in the cache
            setCache(joinedPath, {
              reduxMounted: reduxMounted,
              selectors: selectors
            });
          }
        }

        // store the props given to the component in nextProps.
        // already fill it with the props passed to the component from above
        var nextProps = Object.assign({}, nextOwnProps);

        // and add to props
        if (selectors) {
          Object.keys(selectors).forEach(function (selectorKey) {
            nextProps[selectorKey] = selectors[selectorKey](nextState, nextOwnProps);
          });
        }

        // actions need to be created just once, see if they are cached
        var actions = getCache(joinedPath, 'actions');

        // nothing was in the cache, so create them
        if (!actions) {
          actions = nextOwnProps.actions ? Object.assign({}, nextOwnProps.actions) : {};

          // pass conneted actions as they are, just wrap with dispatch
          // ... unless they have a "keyCreator" that was added with "logic.withKey(keyCreator)"
          var connectedActionKeys = Object.keys(output.connected.actions);
          connectedActionKeys.forEach(function (actionKey) {
            var connectedAction = output.connected.actions[actionKey];
            // we need to inject the latest key before calling the action
            if (connectedAction._keaKeyCreator) {
              actions[actionKey] = function () {
                var actionResponse = connectedAction.apply(undefined, arguments);
                // an object! add the key and dispatch
                if ((typeof actionResponse === 'undefined' ? 'undefined' : _typeof(actionResponse)) === 'object') {
                  var connectedKey = typeof connectedAction._keaKeyCreator === 'function' ? connectedAction._keaKeyCreator(nextOwnProps) : connectedAction._keaKeyCreator;
                  return dispatch(Object.assign({}, actionResponse, { payload: Object.assign({ key: connectedKey }, actionResponse.payload) }));
                } else {
                  // a function? a string? return it!
                  return dispatch(actionResponse);
                }
              };
            } else {
              actions[actionKey] = function () {
                return dispatch(connectedAction.apply(undefined, arguments));
              };
            }
          });

          // inject key to the payload of created actions, if there is a key
          var createdActionKeys = Object.keys(output.created.actions);
          createdActionKeys.forEach(function (actionKey) {
            if (key) {
              actions[actionKey] = function () {
                var _output$created$actio;

                var actionResponse = (_output$created$actio = output.created.actions)[actionKey].apply(_output$created$actio, arguments);

                // an object! add the key and dispatch
                if ((typeof actionResponse === 'undefined' ? 'undefined' : _typeof(actionResponse)) === 'object') {
                  return dispatch(Object.assign({}, actionResponse, { payload: Object.assign({ key: key }, actionResponse.payload) }));
                } else {
                  // a function? a string? return it!
                  return dispatch(actionResponse);
                }
              };
            } else {
              actions[actionKey] = function () {
                var _output$created$actio2;

                return dispatch((_output$created$actio2 = output.created.actions)[actionKey].apply(_output$created$actio2, arguments));
              };
            }
          });

          setCache(joinedPath, { actions: actions });
        }

        // if the props did not change, return the old cached output
        if (!result || !shallowEqual(lastProps, nextProps)) {
          lastProps = nextProps;
          result = Object.assign({}, nextProps, { actions: actions, dispatch: dispatch });
        }

        return result;
      };
    };

    // connect this function to Redux
    var KonnektedKlass = connectAdvanced(selectorFactory, { methodName: 'kea' })(Klass);

    // If we were wrapping a stateless functional React component, add the plugin code to the connected component.
    if (isStateless(Klass)) {
      plugins.injectToConnectedClass.forEach(function (f) {
        return f(input, output, KonnektedKlass);
      });
    }

    return KonnektedKlass;
  };

  // the response will contain a path only if
  // - it's a singleton
  // - or we manually specified a path
  // - or it contains some data (e.g. reducers)
  response.path = output.isSingleton && (hasManualPath || hasLogic) ? output.path : undefined;

  response.constants = output.constants;
  response.actions = output.actions;
  response.propTypes = output.propTypes;

  if (output.isSingleton) {
    response.reducer = output.reducer;
    response.reducers = output.reducers;
    response.defaults = output.defaults;
    response.selector = output.selector;
    response.selectors = output.selectors;
  } else {
    response.withKey = function (keyCreator) {
      var safe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var selectorFunction = safe ? safePathSelector : pathSelector;

      var withKeyResponse = function withKeyResponse(state, params) {
        var key = typeof keyCreator === 'function' ? keyCreator(params) : keyCreator;
        return selectorFunction(input.path(key), state);
      };

      withKeyResponse._keaKeyCreator = keyCreator;
      withKeyResponse.actions = response.actions;
      withKeyResponse.constants = response.constants;
      withKeyResponse.propTypes = {};

      // find propTypes
      var reducerObjects = input.reducers ? convertReducerArrays(input.reducers(output)) : {};
      // run plugins on the created reducer objects
      plugins.mutateReducerObjects.forEach(function (f) {
        return f(input, output, reducerObjects);
      });
      // add propTypes
      Object.keys(reducerObjects).forEach(function (reducerKey) {
        var reducerObject = reducerObjects[reducerKey];
        if (reducerObject.type) {
          withKeyResponse.propTypes[reducerKey] = reducerObject.type;
        }
      });

      // TODO: add selectors

      return withKeyResponse;
    };
  }

  response._isKeaFunction = true;
  response._isKeaSingleton = output.isSingleton;

  response._hasKeaConnect = hasConnect;
  response._hasKeaLogic = hasLogic;
  response._keaPlugins = output.activePlugins;

  plugins.addToResponse.forEach(function (f) {
    return f(input, output, response);
  });

  return response;
}