import _Object$assign from 'babel-runtime/core-js/object/assign';
import _regeneratorRuntime from 'babel-runtime/regenerator';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import { select, call } from 'redux-saga/effects';
import createSagaMiddleware from 'redux-saga';

import createSaga from './create-saga';
import getConnectedSagas from './get-connected';
import injectSagasIntoClass from './inject-to-component';
import createCombinedSaga from './create-combined';
import { keaSaga } from './saga';

export default {
  name: 'saga',

  // must be used globally
  global: true,
  local: false,

  beforeReduxStore: function beforeReduxStore(options) {
    options._sagaMiddleware = createSagaMiddleware();
    options.middleware.push(options._sagaMiddleware);
  },

  afterReduxStore: function afterReduxStore(options, store) {
    options._sagaMiddleware.run(keaSaga);
    store._sagaMiddleware = options._sagaMiddleware;
  },

  isActive: function isActive(input) {
    return !!(input.sagas || input.start || input.stop || input.takeEvery || input.takeLatest || input.connect && input.connect.sagas);
  },

  afterConnect: function afterConnect(input, output) {
    var connect = input.connect || {};
    var connectedSagas = getConnectedSagas(connect);

    // sagas we automatically connect from actions && props
    if (connectedSagas.length > 0) {
      output.activePlugins.saga = true;
      input.sagas = input.sagas ? input.sagas.concat(connectedSagas) : connectedSagas;
    }

    // we have input: { connect: { sagas: [] } }, add to input: { sagas: [] }
    if (connect.sagas) {
      input.sagas = input.sagas ? input.sagas.concat(connect.sagas) : connect.sagas;
    }
  },

  afterCreateSingleton: function afterCreateSingleton(input, output) {
    var isActive = output.activePlugins.saga;
    var hasSelectors = !!(output.selectors && _Object$keys(output.selectors).length > 0);

    if (hasSelectors) {
      output.get = _regeneratorRuntime.mark(function _callee(key) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return select(key ? output.selectors[key] : output.selector);

              case 2:
                return _context.abrupt('return', _context.sent);

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      });

      output.fetch = _regeneratorRuntime.mark(function _callee2() {
        var results,
            keys,
            i,
            _args2 = arguments;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                results = {};
                keys = Array.isArray(_args2[0]) ? _args2[0] : _args2;
                i = 0;

              case 3:
                if (!(i < keys.length)) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 6;
                return output.get(keys[i]);

              case 6:
                results[keys[i]] = _context2.sent;

              case 7:
                i++;
                _context2.next = 3;
                break;

              case 10:
                return _context2.abrupt('return', results);

              case 11:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      });
    }

    if (isActive) {
      var singletonSagaBase = {
        constants: _Object$assign({}, output.constants),
        actions: _Object$assign({}, output.actions),
        start: input.start,
        stop: input.stop,
        takeEvery: input.takeEvery,
        takeLatest: input.takeLatest,
        workers: input.workers ? _Object$assign({}, input.workers) : {},
        key: output.key,
        path: output.path,
        get: output.get,
        fetch: output.fetch

        // if saga is a logic store, take it's ".saga", otherwise assume it's a generator function
      };var sagas = (input.sagas || []).map(function (saga) {
        return saga && saga._keaPlugins && saga._keaPlugins.saga && saga.saga || saga;
      });

      if (input.start || input.stop || input.takeEvery || input.takeLatest) {
        output._createdSaga = createSaga(singletonSagaBase);
        output.workers = singletonSagaBase.workers;
        sagas.push(output._createdSaga);
      }

      output.saga = _regeneratorRuntime.mark(function _callee3() {
        var sagaPath;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                sagaPath = output.path ? output.path.join('.') : input.path('').filter(function (p) {
                  return p;
                }).join('.');
                _context3.next = 3;
                return call(createCombinedSaga(sagas, sagaPath));

              case 3:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      });
    }
  },

  injectToClass: function injectToClass(input, output, Klass) {
    if (output.activePlugins.saga) {
      injectSagasIntoClass(Klass, input, output);
    }
  },

  injectToConnectedClass: function injectToConnectedClass(input, output, KonnektedKlass) {
    if (output.activePlugins.saga) {
      injectSagasIntoClass(KonnektedKlass, input, output);
    }
  },

  addToResponse: function addToResponse(input, output, response) {
    if (output.activePlugins.saga) {
      response.saga = output.saga;
      response.workers = output.workers;
    }
    response.get = output.get;
    response.fetch = output.fetch;
  }
};