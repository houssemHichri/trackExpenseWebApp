import _regeneratorRuntime from 'babel-runtime/regenerator';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import { call, cancelled, take, takeEvery, takeLatest } from 'redux-saga/effects';

// this = object with keys { takeEvery, takeLatest, start, stop }
// object = what is merged into _this after actions are created
export default function createSaga(_this) {
  var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // bind all functions to _this
  var keys = _Object$keys(_this);
  for (var i = 0; i < keys.length; i++) {
    if (typeof _this[keys[i]] === 'function') {
      _this[keys[i]] = _this[keys[i]].bind(_this);
    }
  }

  if (_this.workers) {
    var _keys = _Object$keys(_this.workers);
    for (var _i = 0; _i < _keys.length; _i++) {
      if (typeof _this.workers[_keys[_i]] === 'function') {
        _this.workers[_keys[_i]] = _this.workers[_keys[_i]].bind(_this);
      }
    }
  }

  _Object$assign(_this, object);

  // generate the saga
  return _regeneratorRuntime.mark(function _callee() {
    var ops, opKeys, k, op, list, _keys2, _i2, fn, j;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            // start takeEvery and takeLatest watchers
            ops = { takeEvery: takeEvery, takeLatest: takeLatest };
            opKeys = _Object$keys(ops);
            k = 0;

          case 4:
            if (!(k < opKeys.length)) {
              _context.next = 30;
              break;
            }

            op = opKeys[k];

            if (!_this[op]) {
              _context.next = 27;
              break;
            }

            list = _this[op](_this);
            _keys2 = _Object$keys(list);
            _i2 = 0;

          case 10:
            if (!(_i2 < _keys2.length)) {
              _context.next = 27;
              break;
            }

            fn = list[_keys2[_i2]];

            if (!Array.isArray(fn)) {
              _context.next = 22;
              break;
            }

            j = 0;

          case 14:
            if (!(j < fn.length)) {
              _context.next = 20;
              break;
            }

            _context.next = 17;
            return ops[op](_keys2[_i2], fn[j].bind(_this));

          case 17:
            j++;
            _context.next = 14;
            break;

          case 20:
            _context.next = 24;
            break;

          case 22:
            _context.next = 24;
            return ops[op](_keys2[_i2], fn.bind(_this));

          case 24:
            _i2++;
            _context.next = 10;
            break;

          case 27:
            k++;
            _context.next = 4;
            break;

          case 30:
            if (!_this.start) {
              _context.next = 33;
              break;
            }

            _context.next = 33;
            return call(_this.start);

          case 33:
            if (!(_this.stop || _this.cancelled)) {
              _context.next = 39;
              break;
            }

          case 34:
            if (!true) {
              _context.next = 39;
              break;
            }

            _context.next = 37;
            return take('wait until worker cancellation');

          case 37:
            _context.next = 34;
            break;

          case 39:
            _context.prev = 39;
            _context.next = 42;
            return cancelled();

          case 42:
            if (!_context.sent) {
              _context.next = 46;
              break;
            }

            if (!_this.stop) {
              _context.next = 46;
              break;
            }

            _context.next = 46;
            return call(_this.stop);

          case 46:
            return _context.finish(39);

          case 47:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[0,, 39, 47]]);
  });
}